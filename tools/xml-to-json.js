#!/usr/bin/env node
/**
 * Converts Unity XML documentation to JSON for the documentation site.
 *
 * Usage: node xml-to-json.js <input.xml> <output.json>
 *
 * Input: UniText.xml (generated by Unity compiler with -doc flag)
 * Output: api.json (structured data for React documentation site)
 */

const fs = require('fs');
const path = require('path');
const { XMLParser } = require('fast-xml-parser');

// Category mappings for navigation
const CATEGORIES = {
    core: [
        'TextProcessor',
        'TextProcessSettings',
        'UniTextBuffers',
        'UniTextMeshGenerator',
        'TextLayout',
        'UniText',
        'UniTextRenderData',
        'SharedPipelineComponents',
        'UniTextWorkerPool',
        'UniTextSettings',
        'UniTextDebug',
        'DirtyFlags',
        'HorizontalAlignment',
        'VerticalAlignment',
        'LayoutSettings',
        'SharedMeshPool',
        'GeneratedMeshSegment',
        'Cat'
    ],
    unicode: [
        'Bidi',
        'ScriptAnalyzer',
        'Script',
        'LineBreak',
        'Grapheme',
        'UnicodeData',
        'UnicodeProps',
        'UnicodeBinaryWriter',
        'IUnicodeDataProvider',
        'BinaryUnicodeDataProvider',
        'GeneralCategory',
        'EastAsianWidth',
        'Joining',
        'Indic',
        'Mirror',
        'Bracket',
        'RangeEntry',
        'IRangeEntry',
        'TextDirection',
        'DefaultIgnorableRangeEntry',
        'ExtendedPictographicRangeEntry'
    ],
    shaping: [
        'Shaper',
        'HybridShaper',
        'HarfBuzzShaper',
        'SimpleShaper',
        'IShaper',
        'ShapingResult',
        'ShapedRun',
        'ShapedGlyph'
    ],
    fonts: [
        'UniTextFont',
        'UniTextFonts',
        'UniTextAppearance',
        'UniTextFontProvider',
        'UniTextFontEngine',
        'UniTextCharacter',
        'FreeType',
        'FaceInfo',
        'SharedFontCache',
        'FontMaterialPair',
        'CachedGlyphData',
        'CachedTransformData',
        'RenderedGlyph',
        'RenderedGlyphData'
    ],
    modifiers: [
        'BaseModifier',
        'GlyphModifier',
        'AttributeParser',
        'ModRegister',
        'IParseRule',
        'TagParseRule',
        'ParsedRange',
        'LinkModifier',
        'ColorModifier',
        'UnderlineModifier',
        'IAttributeData',
        'LinkData',
        'ModifierBufferExtensions'
    ],
    structures: [
        'TextRun',
        'TextLine',
        'TextRange',
        'PositionedGlyph',
        'TextHitResult',
        'FastIntDictionary',
        'PooledList',
        'PooledBuffer',
        'PooledArrayAttribute',
        'IPointEntry'
    ],
    emoji: [
        'Emoji',
        'SystemEmojiFont',
        'WebGLEmoji',
        'WebGLEmojiShaper'
    ]
};

// Priority within each category (types listed first = higher priority)
// Only include types that exist in api.json as standalone types
const CATEGORY_PRIORITY = {
    core: ['UniText', 'TextProcessor', 'TextLayout', 'UniTextBuffers', 'UniTextMeshGenerator', 'UniTextRenderData', 'UniTextSettings'],
    unicode: ['BidiEngine', 'BidiParagraph', 'BidiParagraphDirection', 'BidiResult', 'UnicodeScript', 'IUnicodeDataProvider', 'BinaryUnicodeDataProvider'],
    shaping: ['HybridShaper', 'HarfBuzzShaper', 'SimpleShaper', 'IShaper', 'Shaper', 'ShapingResult'],
    fonts: ['UniTextFont', 'UniTextFonts', 'UniTextAppearance', 'UniTextFontProvider', 'UniTextCharacter'],
    modifiers: ['BaseModifier', 'GlyphModifier', 'ModRegister', 'IParseRule', 'TagParseRule'],
    structures: ['TextRun', 'TextLine', 'PositionedGlyph', 'TextHitResult', 'PooledBuffer', 'PooledList'],
    emoji: ['EmojiFont', 'SystemEmojiFont']
};

// Patterns to exclude from documentation (Unity auto-generated types)
const EXCLUDED_PATTERNS = ['UnitySourceGenerated', 'MonoScriptData', '__'];

// ============================================================================
// XML Parser with preserveOrder: true
// ============================================================================

function parseXml(xmlContent) {
    const parser = new XMLParser({
        ignoreAttributes: false,
        attributeNamePrefix: '@_',
        textNodeName: '#text',
        preserveOrder: true,  // Critical for mixed content
        trimValues: false     // Preserve whitespace for proper text extraction
    });

    return parser.parse(xmlContent);
}

// ============================================================================
// Helper functions for navigating preserveOrder structure
// ============================================================================

/**
 * Find first element with given tag name in an ordered array.
 * With preserveOrder: true, structure is: [{ tagName: [...] }, { tagName2: [...] }]
 */
function findElement(arr, tagName) {
    if (!Array.isArray(arr)) return null;
    for (const item of arr) {
        if (item && item[tagName] !== undefined) {
            return item;
        }
    }
    return null;
}

/**
 * Find all elements with given tag name.
 */
function findAllElements(arr, tagName) {
    if (!Array.isArray(arr)) return [];
    return arr.filter(item => item && item[tagName] !== undefined);
}

/**
 * Get attribute value from element.
 * Attributes are stored in ':@' property.
 */
function getAttr(element, attrName) {
    if (!element || !element[':@']) return null;
    return element[':@']['@_' + attrName];
}

/**
 * Get child content array of an element.
 */
function getChildren(element, tagName) {
    if (!element || !element[tagName]) return [];
    return element[tagName];
}

// ============================================================================
// Text extraction (handles mixed content properly)
// ============================================================================

/**
 * Extract text from an ordered node array, preserving text order.
 * Handles mixed content like: "text <see cref='...'/>  more text"
 */
function extractText(nodeArray) {
    if (!nodeArray) return null;
    if (!Array.isArray(nodeArray)) return null;

    const parts = [];

    for (const node of nodeArray) {
        if (!node) continue;

        // Text node
        if (node['#text'] !== undefined) {
            parts.push(node['#text']);
            continue;
        }

        // <see cref="..."/> - extract type/member name
        if (node['see'] !== undefined) {
            const cref = getAttr(node, 'cref');
            const langword = getAttr(node, 'langword');

            if (langword) {
                parts.push(' ' + langword + ' ');
            } else if (cref) {
                const displayName = formatCrefForDisplay(cref);
                parts.push(' ' + displayName + ' ');
            }

            // Also extract any inner text
            const innerText = extractText(node['see']);
            if (innerText) parts.push(innerText);
            continue;
        }

        // <paramref name="..."/>
        if (node['paramref'] !== undefined) {
            const name = getAttr(node, 'name');
            if (name) parts.push(' ' + name + ' ');
            continue;
        }

        // <typeparamref name="..."/>
        if (node['typeparamref'] !== undefined) {
            const name = getAttr(node, 'name');
            if (name) parts.push(' ' + name + ' ');
            continue;
        }

        // <c>code</c> - inline code
        if (node['c'] !== undefined) {
            const codeText = extractText(node['c']);
            if (codeText) parts.push(' ' + codeText + ' ');
            continue;
        }

        // <para>, <list>, <item>, etc. - recurse into content
        for (const key of Object.keys(node)) {
            if (key === ':@') continue; // Skip attributes
            const childText = extractText(node[key]);
            if (childText) parts.push(' ' + childText + ' ');
        }
    }

    // Join and normalize whitespace
    const text = parts.join('');
    return normalizeWhitespace(text);
}

function normalizeWhitespace(text) {
    if (!text) return null;
    let normalized = text
        .replace(/\s+/g, ' ')           // Collapse multiple whitespace
        .replace(/\s+([.,;:!?)])/g, '$1') // Remove space before punctuation
        .replace(/\(\s+/g, '(')          // Remove space after opening paren
        .trim();
    return normalized || null;
}

// ============================================================================
// Name formatting utilities
// ============================================================================

function formatGenericName(name) {
    if (!name) return '';
    // Convert `1 -> <T>, `2 -> <T1, T2>, etc.
    let result = name.replace(/`(\d+)/g, (_, count) => {
        const num = parseInt(count);
        if (num === 1) return '<T>';
        const params = Array.from({ length: num }, (_, i) => `T${i + 1}`);
        return `<${params.join(', ')}>`;
    });
    // Remove orphan backticks (e.g., `<T> -> <T>)
    result = result.replace(/`(?=<)/g, '');
    return result;
}

/**
 * Format a cref attribute value for display in text.
 * Handles types, methods, properties, fields, events.
 * Examples:
 *   T:UniText -> UniText
 *   M:TextProcessor.EnsureFirstPass(System.ReadOnlySpan{System.Char},TextProcessSettings) -> EnsureFirstPass(...)
 *   P:UniText.Text -> Text
 */
function formatCrefForDisplay(cref) {
    if (!cref) return '';

    // Remove prefix (T:, M:, P:, F:, E:)
    const withoutPrefix = cref.replace(/^[TMFPE]:/, '');

    // Split into path and parameters
    const parenIndex = withoutPrefix.indexOf('(');
    let path, params;

    if (parenIndex !== -1) {
        path = withoutPrefix.slice(0, parenIndex);
        params = withoutPrefix.slice(parenIndex);
    } else {
        path = withoutPrefix;
        params = '';
    }

    // Extract member name (last part of path)
    const parts = path.split('.');
    let name = parts[parts.length - 1];

    // Handle constructors
    if (name === '#ctor') {
        name = parts.length > 1 ? parts[parts.length - 2] : 'Constructor';
    }

    // Format generic backticks in name
    name = formatGenericName(name);

    // For methods, add simplified parameters indicator
    if (params) {
        // Just indicate there are parameters, don't show full signature in text
        return name + '(...)';
    }

    return name;
}

function extractTypeName(fullName) {
    if (!fullName) return '';
    const withoutPrefix = fullName.replace(/^[TMFPE]:/, '');
    const withoutParams = withoutPrefix.split('(')[0];
    const parts = withoutParams.split('.');
    let name = parts[parts.length - 1];

    if (name === '#ctor') {
        const className = parts.length > 1 ? parts[parts.length - 2] : 'Constructor';
        name = formatGenericName(className);
    } else {
        name = formatGenericName(name);
    }

    return name;
}

function formatParamType(type) {
    const typeMap = {
        'System.Single': 'float',
        'System.Double': 'double',
        'System.Int32': 'int',
        'System.Int64': 'long',
        'System.UInt32': 'uint',
        'System.UInt64': 'ulong',
        'System.Int16': 'short',
        'System.UInt16': 'ushort',
        'System.Byte': 'byte',
        'System.SByte': 'sbyte',
        'System.String': 'string',
        'System.Boolean': 'bool',
        'System.Void': 'void',
        'System.Object': 'object',
        'System.Char': 'char'
    };

    let modifier = '';
    if (type.endsWith('@')) {
        modifier = 'ref ';
        type = type.slice(0, -1);
    }

    // Handle arrays first (before other processing)
    if (type.endsWith('[]')) {
        const elementType = formatParamType(type.slice(0, -2));
        return modifier + elementType + '[]';
    }

    // Handle standalone type parameters: `0 -> T, `1 -> T2, etc.
    // These are references to the containing type's generic parameters
    const typeParamMatch = type.match(/^`(\d+)$/);
    if (typeParamMatch) {
        const index = parseInt(typeParamMatch[1]);
        return modifier + (index === 0 ? 'T' : 'T' + (index + 1));
    }

    // Handle method type parameters: ``0 -> TMethod, ``1 -> TMethod2
    const methodParamMatch = type.match(/^``(\d+)$/);
    if (methodParamMatch) {
        const index = parseInt(methodParamMatch[1]);
        return modifier + (index === 0 ? 'TMethod' : 'TMethod' + (index + 1));
    }

    // Handle generic types with {...}
    const braceIndex = type.indexOf('{');
    if (braceIndex !== -1) {
        const basePart = type.slice(0, braceIndex);
        const genericPart = type.slice(braceIndex + 1, -1); // Remove { and }

        // Parse generic arguments (handle nested generics)
        const genericArgs = parseGenericArgs(genericPart);
        const formattedArgs = genericArgs.map(arg => formatParamType(arg));

        // Format base type (remove backtick suffix like `1, `2)
        let baseName = extractSimpleName(basePart);
        baseName = baseName.replace(/`\d+$/, '');

        return modifier + baseName + '<' + formattedArgs.join(', ') + '>';
    }

    // Simple type - apply type map and extract simple name
    const mapped = typeMap[type] || type;
    let result = extractSimpleName(mapped);

    // Handle generic type definitions like PooledBuffer`1 -> PooledBuffer<T>
    result = formatGenericName(result);

    return modifier + result;
}

function extractSimpleName(fullName) {
    const parts = fullName.split('.');
    return parts[parts.length - 1];
}

function parseGenericArgs(argsString) {
    const args = [];
    let depth = 0;
    let current = '';

    for (const char of argsString) {
        if (char === '{') {
            depth++;
            current += char;
        } else if (char === '}') {
            depth--;
            current += char;
        } else if (char === ',' && depth === 0) {
            args.push(current.trim());
            current = '';
        } else {
            current += char;
        }
    }

    if (current.trim()) {
        args.push(current.trim());
    }

    return args;
}

function formatFullId(fullName) {
    if (!fullName) return '';
    const withoutPrefix = fullName.replace(/^[TMFPE]:/, '');

    const parenIndex = withoutPrefix.indexOf('(');
    if (parenIndex === -1) {
        return formatGenericName(withoutPrefix);
    }

    const pathPart = withoutPrefix.slice(0, parenIndex);
    const paramsStr = withoutPrefix.slice(parenIndex + 1, -1);

    const params = [];
    if (paramsStr) {
        let depth = 0;
        let current = '';
        for (const char of paramsStr) {
            if (char === '{') depth++;
            else if (char === '}') depth--;
            else if (char === ',' && depth === 0) {
                params.push(formatParamType(current.trim()));
                current = '';
                continue;
            }
            current += char;
        }
        if (current.trim()) {
            params.push(formatParamType(current.trim()));
        }
    }

    return formatGenericName(pathPart) + '(' + params.join(', ') + ')';
}

// ============================================================================
// Member extraction
// ============================================================================

function getMemberKind(name) {
    if (!name) return 'unknown';
    if (name.startsWith('T:')) return 'type';
    if (name.startsWith('M:')) return 'method';
    if (name.startsWith('P:')) return 'property';
    if (name.startsWith('F:')) return 'field';
    if (name.startsWith('E:')) return 'event';
    return 'unknown';
}

function getTypeKind(summary) {
    if (!summary) return 'class';
    const lower = summary.toLowerCase();
    if (lower.includes('interface')) return 'interface';
    if (lower.includes('enum')) return 'enum';
    if (lower.includes('struct')) return 'struct';
    return 'class';
}

function parseSignature(name) {
    const match = name.match(/^[MFPE]:([^(]+)(?:\(([^)]*)\))?$/);
    if (!match) return { fullName: name };

    const fullPath = match[1];
    const rawParams = match[2] || '';

    const params = [];
    if (rawParams) {
        let depth = 0;
        let current = '';
        for (const char of rawParams) {
            if (char === '{') depth++;
            else if (char === '}') depth--;
            else if (char === ',' && depth === 0) {
                params.push(formatParamType(current.trim()));
                current = '';
                continue;
            }
            current += char;
        }
        if (current.trim()) {
            params.push(formatParamType(current.trim()));
        }
    }

    const parts = fullPath.split('.');
    let memberName = parts.pop();
    const typeName = formatGenericName(parts.join('.'));

    const isConstructor = memberName === '#ctor';
    if (isConstructor) {
        memberName = formatGenericName(parts[parts.length - 1] || 'Constructor');
    } else {
        memberName = formatGenericName(memberName);
    }

    return {
        fullName: formatGenericName(fullPath),
        typeName,
        memberName,
        paramTypes: params,
        isConstructor
    };
}

function shouldExclude(name) {
    return EXCLUDED_PATTERNS.some(pattern => name.includes(pattern));
}

function extractSeeAlso(memberContent) {
    const seeAlsoElements = findAllElements(memberContent, 'seealso');
    return seeAlsoElements
        .map(elem => {
            const cref = getAttr(elem, 'cref');
            if (cref) return extractTypeName(cref);
            const href = getAttr(elem, 'href');
            if (href) return { href, text: extractText(elem['seealso']) };
            return null;
        })
        .filter(Boolean);
}

function extractParams(memberContent) {
    const paramElements = findAllElements(memberContent, 'param');
    return paramElements.map(elem => ({
        name: getAttr(elem, 'name') || '',
        description: extractText(elem['param']) || ''
    }));
}

function extractExceptions(memberContent) {
    const exceptionElements = findAllElements(memberContent, 'exception');
    return exceptionElements.map(elem => ({
        type: extractTypeName(getAttr(elem, 'cref') || ''),
        condition: extractText(elem['exception']) || ''
    }));
}

function processMember(memberElement) {
    const name = getAttr(memberElement, 'name') || '';
    if (shouldExclude(name)) return null;

    const content = memberElement['member'] || [];
    const kind = getMemberKind(name);

    // For partial classes, Unity merges multiple summary/remarks into one member
    // Use findElement for single elements, findAllElements for merged ones
    const summaryElem = findElement(content, 'summary');
    const exampleElem = findElement(content, 'example');
    const returnsElem = findElement(content, 'returns');
    const valueElem = findElement(content, 'value');

    // Collect ALL remarks (for partial classes with multiple remarks blocks)
    const allRemarksElems = findAllElements(content, 'remarks');
    let remarks = null;
    if (allRemarksElems.length > 0) {
        const remarksParts = allRemarksElems
            .map(elem => extractText(elem['remarks']))
            .filter(Boolean);
        remarks = remarksParts.length > 0 ? remarksParts.join(' ') : null;
    }

    return {
        id: formatFullId(name),
        name: extractTypeName(name),
        kind,
        summary: summaryElem ? extractText(summaryElem['summary']) : null,
        remarks,
        example: exampleElem ? extractText(exampleElem['example']) : null,
        params: extractParams(content),
        returns: returnsElem ? extractText(returnsElem['returns']) : null,
        value: valueElem ? extractText(valueElem['value']) : null,
        exceptions: extractExceptions(content),
        seeAlso: extractSeeAlso(content),
        ...parseSignature(name)
    };
}

function processMembers(membersContent) {
    const memberElements = findAllElements(membersContent, 'member');
    return memberElements
        .map(processMember)
        .filter(Boolean);
}

// ============================================================================
// Type grouping and categorization
// ============================================================================

function groupMembersByType(members) {
    const types = new Map();

    for (const member of members) {
        if (member.kind === 'type') {
            const typeName = member.name;
            if (!types.has(typeName)) {
                types.set(typeName, {
                    id: member.id,
                    name: typeName,
                    kind: getTypeKind(member.summary),
                    summary: member.summary,
                    remarks: member.remarks,
                    example: member.example,
                    seeAlso: member.seeAlso,
                    category: categorizeType(typeName),
                    members: { methods: [], properties: [], fields: [], events: [] }
                });
            } else {
                const existing = types.get(typeName);
                existing.summary = existing.summary || member.summary;
                // Merge remarks from partial classes
                if (member.remarks) {
                    if (existing.remarks && !existing.remarks.includes(member.remarks)) {
                        existing.remarks = existing.remarks + ' ' + member.remarks;
                    } else if (!existing.remarks) {
                        existing.remarks = member.remarks;
                    }
                }
                existing.example = existing.example || member.example;
                // Merge seeAlso from partial classes
                if (member.seeAlso && member.seeAlso.length > 0) {
                    const existingRefs = new Set(existing.seeAlso.map(s => typeof s === 'string' ? s : s.href));
                    for (const ref of member.seeAlso) {
                        const key = typeof ref === 'string' ? ref : ref.href;
                        if (!existingRefs.has(key)) {
                            existing.seeAlso.push(ref);
                        }
                    }
                }
            }
        }
    }

    for (const member of members) {
        if (member.kind === 'type') continue;

        const typeName = member.typeName?.split('.').pop() || '';
        if (!types.has(typeName)) {
            types.set(typeName, {
                id: typeName,
                name: typeName,
                kind: 'class',
                summary: null,
                remarks: null,
                example: null,
                seeAlso: [],
                category: categorizeType(typeName),
                members: { methods: [], properties: [], fields: [], events: [] }
            });
        }

        const type = types.get(typeName);
        switch (member.kind) {
            case 'method': type.members.methods.push(member); break;
            case 'property': type.members.properties.push(member); break;
            case 'field': type.members.fields.push(member); break;
            case 'event': type.members.events.push(member); break;
        }
    }

    return Array.from(types.values()).filter(t => t.name && t.name.length > 0);
}

function categorizeType(typeName) {
    for (const [category, patterns] of Object.entries(CATEGORIES)) {
        if (patterns.some(p => typeName.includes(p))) {
            return category;
        }
    }
    return 'other';
}

function getTypePriority(typeName, category) {
    const priorityList = CATEGORY_PRIORITY[category];
    if (!priorityList) return 100;

    const exactIndex = priorityList.indexOf(typeName);
    if (exactIndex !== -1) return exactIndex + 1;

    for (let i = 0; i < priorityList.length; i++) {
        if (typeName.includes(priorityList[i]) || priorityList[i].includes(typeName.replace(/<.*>/, ''))) {
            return i + 1;
        }
    }

    return 100;
}

function buildCategories(types) {
    const categoryOrder = ['emoji', 'fonts', 'modifiers', 'shaping', 'structures', 'unicode', 'core'];
    const categories = {};
    const assigned = new Set();

    for (const category of Object.keys(CATEGORIES)) {
        categories[category] = [];
    }

    for (const category of categoryOrder) {
        const patterns = CATEGORIES[category];
        for (const type of types) {
            if (assigned.has(type.name)) continue;
            if (patterns.some(pattern => type.name.includes(pattern))) {
                const priority = getTypePriority(type.name, category);
                categories[category].push({ name: type.name, priority });
                assigned.add(type.name);
            }
        }
    }

    for (const category of Object.keys(categories)) {
        categories[category].sort((a, b) => {
            if (a.priority !== b.priority) return a.priority - b.priority;
            return a.name.localeCompare(b.name);
        });
    }

    categories.other = types
        .filter(t => !assigned.has(t.name))
        .map(t => ({ name: t.name, priority: 100 }))
        .sort((a, b) => a.name.localeCompare(b.name));

    return categories;
}

// ============================================================================
// Main conversion
// ============================================================================

function convert(xmlContent, version = '0.9.0') {
    const parsed = parseXml(xmlContent);

    // Navigate preserveOrder structure: [{ doc: [...] }]
    const docElement = findElement(parsed, 'doc');
    if (!docElement) {
        throw new Error('Invalid XML documentation format: missing <doc> element');
    }

    const docContent = docElement['doc'];
    const membersElement = findElement(docContent, 'members');
    if (!membersElement) {
        throw new Error('Invalid XML documentation format: missing <members> element');
    }

    const membersContent = membersElement['members'];
    const members = processMembers(membersContent);
    const types = groupMembersByType(members);
    const categories = buildCategories(types);

    return {
        version,
        generatedAt: new Date().toISOString(),
        namespaces: [],
        types: types.sort((a, b) => a.name.localeCompare(b.name)),
        categories
    };
}

function main() {
    const args = process.argv.slice(2);

    if (args.length < 2) {
        console.error('Usage: node xml-to-json.js <input.xml> <output.json> [version]');
        console.error('');
        console.error('Example: node xml-to-json.js UniText.xml api.json 0.9.0');
        process.exit(1);
    }

    const [inputPath, outputPath, version] = args;

    if (!fs.existsSync(inputPath)) {
        console.error(`Error: Input file not found: ${inputPath}`);
        process.exit(1);
    }

    console.log(`Reading: ${inputPath}`);
    const xmlContent = fs.readFileSync(inputPath, 'utf-8');

    console.log('Converting XML to JSON (preserveOrder mode)...');
    const result = convert(xmlContent, version || '0.9.0');

    console.log(`Writing: ${outputPath}`);
    fs.writeFileSync(outputPath, JSON.stringify(result, null, 2), 'utf-8');

    console.log(`Done! Processed ${result.types.length} types.`);
    console.log('Categories:');
    for (const [cat, types] of Object.entries(result.categories)) {
        if (types.length > 0) {
            console.log(`  ${cat}: ${types.length} types`);
        }
    }
}

main();
